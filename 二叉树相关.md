## 617、合并二叉树
对应位置的值相加，没有值为0
```java
  public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if (t1 == null){
            return t2;
        }
        if (t2 == null){
            return t1;
        }
        TreeNode node = new TreeNode(t1.val + t2.val);
        node.left = mergeTrees(t1.left, t2.left);
        node.right = mergeTrees(t1.right, t2.right);
        return node;
    }
```
## 101、对称二叉树
```java
  public boolean isSymmetric(TreeNode root) {
        if (root == null){
            return true;
        }
        return dfs(root.left, root.right);
    }

    private boolean dfs(TreeNode left, TreeNode right) {
        if (left == null && right == null){
            return true;
        }
        if (left == null || right == null){
            return false;
        }
        if (left.val != right.val){
            return false;
        }
        return dfs(left.left, right.right) && dfs(left.right, right.left);
    }
```
## 226 翻转二叉树
```java
    public TreeNode invertTree(TreeNode root) {
        if (root == null){
            return root;
        }
        TreeNode left = root.left;
        root.left = root.right;
        root.right = left;
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
```
## 98 验证二叉搜索树
BST的性质就是左子树<root<右子树，所以采用中序遍历即可实现，使用pre指针，指向前一个节点
```java
    TreeNode pre = null;
    public boolean isValidBST(TreeNode root) {
        if (root == null){
            return true;
        }
        if (!isValidBST(root.left)){
            return false;
        }
        if (pre != null && pre.val >= root.val){
            return false;
        }
        pre = root;
        return isValidBST(root.right);
    }
```
## 543 二叉树的直径
一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
这个题和二叉树的最大通路和是同样的解法，记录一个全局变量maxlen，每次递归时更新。
```java
    private int maxLen = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        if (root == null){
            return 0;
        }
        pathlen(root);
        return maxLen-1;
    }
    private int pathlen(TreeNode root) {
        if (root == null){
            return 0;
        }
        int leftlen = pathlen(root.left);
        int rightlen = pathlen(root.right);
        int tmplen = leftlen + rightlen + 1;
        if (tmplen > maxLen){
            maxLen = tmplen;
        }
        return leftlen > rightlen?leftlen+1:rightlen+1;
    }
```











