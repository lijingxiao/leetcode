- 19 删除链表的倒数第N个节点
快慢指针
- 206 反转链表：基础做法
- 92 反转链表 II：找到翻转部分，翻转，最后修改翻转部分的前后指针
- 21 合并两个有序链表：递归或者循环
- 23 合并k个有序链表：两两合并，分而治之
- 24 两两交换链表中的节点
- 25 K 个一组翻转链表：维护pre，left，right，翻转left到right之后，更新pre和left的指针







### 25. K 个一组翻转链表
维护3个指针，pre，left，right，记录next，翻转[left,right]，更新pre和反转之后的尾节点（left）指针
```java
public ListNode reverseKGroup(ListNode head, int k) {
    if (head == null || head.next == null || k < 2){
        return head;
    }
    ListNode dummy = new ListNode(-1);
    dummy.next = head;
    ListNode pre = dummy, left = dummy, right = dummy;
    while (right != null){
        int len = 0;
        while (len < k && right != null){
            right = right.next;
            len++;
        }
        if (right == null){
            break;
        }
        ListNode next = right.next;
        right.next = null;
        left = pre.next;
        pre.next = reverse(left);//前驱指向新head
        left.next = next;//新的尾节点指向next
        pre = left;
        right = pre;
    }
    return dummy.next;
}

private ListNode reverse(ListNode head) {
    if (head == null || head.next == null){
        return head;
    }
    ListNode pre = null;
    while (head != null){
        ListNode next = head.next;
        head.next = pre;
        pre = head;
        head = next;
    }
    return pre;
}
```

### 24. 两两交换链表中的节点
pre,p,q,next
```java
public ListNode swapPairs(ListNode head) {
    if (head == null || head.next == null){
        return head;
    }
    ListNode dummy = new ListNode(-1);
    dummy.next = head;
    ListNode pre =dummy, p=head, q = head.next;
    while (p != null && q != null){
        ListNode next = q.next;
        q.next = p;
        pre.next = q;
        p.next = next;

        pre = p;
        p = next;
        if (p != null) {
            q = p.next;
        }
    }
    return dummy.next;
}
```

### 23. 合并k个有序链表
```java
public ListNode mergeKLists(ListNode[] lists) {
    if (lists == null){
        return null;
    }
merge(lists, 0, lists.length-1);
    return lists[0];
}

private void merge(ListNode[] lists, int start, int end) {
    if (start < end){
        int mid = start + (end-start)/2+1;
        for (int i = start; i < mid && i+mid <= end; i++) {
            lists[i] = merge2list(lists[i], lists[mid+i]);
        }
        merge(lists,0,mid-1);
    }
}

private ListNode merge2list(ListNode l1, ListNode l2) {
    if (l1 == null){
        return l2;
    }
    if (l2 == null){
        return l1;
    }
    ListNode dummy = new ListNode(-1);
    ListNode cur = dummy;
    while (l1 != null && l2 != null){
        if (l1.val < l2.val){
            cur.next = l1;
            l1 = l1.next;
        } else {
            cur.next = l2;
            l2 = l2.next;
        }
        cur = cur.next;
    }
    if (l1 != null){
        cur.next = l1;
    }else {
        cur.next = l2;
    }
    return dummy.next;
}
```


### 92. 反转链表 II
找到待翻转部分m~n；翻转；修改翻转部分前后节点的指针
```java
public ListNode reverseBetween(ListNode head, int m, int n) {
    if (head == null || head.next == null || m >= n){
        return head;
    }
    ListNode dummy = new ListNode(-1);
    dummy.next = head;
    ListNode last = dummy;//last指向带翻转部分的前一个节点
    for (int i = 0; i < m - 1; i++) {
        last = last.next;
    }
    ListNode p = last.next;//记录待翻转的第一个节点
    ListNode pre = p, cur = p.next;
    for (int i = 0; i < n - m; i++) {
        ListNode next = cur.next;
        last.next = cur;//插入节点
        cur.next = pre;
        pre = cur;//更新指针
        cur = next;
    }
    last.next = pre;//修改翻转部分前后指针
    p.next = cur;
    return dummy.next;
}
```

### 206. 反转链表
不断头插，pre指向翻转后的头结点，记录每个next
```java
public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null){
        return head;
    }
    ListNode pre = null, cur = head;
    while (cur != null){
        ListNode next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
```

### 19. 删除链表的倒数第N个节点
快慢指针
```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    if (head == null){return head;}
    ListNode dummy = new ListNode(-1);
    dummy.next = head;
    ListNode slow = dummy, fast = dummy, pre = dummy;
    while (n > 0){
        if (fast == null){return head;}//不够n个
        fast = fast.next;
        n--;
    }
    while (fast != null){
        pre = slow;
        slow = slow.next;
        fast = fast.next;
    }
    pre.next = slow.next;
    return dummy.next;
}
```
