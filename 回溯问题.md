# 回溯问题
**当问题需要"回头"，以此来查找出所有的解的时候，使用回溯算法**。即满足结束条件或者发现不是正确路径的时候(走不通)，要撤销选择，回退到上一个状态，继续尝试，直到找出所有解为止

整体的backtrack函数如下
```c
void backtrack(vector<int>nums,vector<int>&path,int start)
{
    res.push_back(path);
    for(int i=start;i<nums.size();i++)
    {
        path.push_back(nums[i]);//做出选择
        backtrack(nums,path,i+1);//递归进入下一层，注意i+1，标识下一个选择列表的开始位置，最重要的一步
        path.pop_back();//撤销选择
    }
}
```

## 78、子集 subsets
非常典型的回溯问题
```java
  public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> lists = new ArrayList<>();
        if (nums == null || nums.length == 0){
            return lists;
        }
        ArrayList<Integer> tmp = new ArrayList<>();
        lists.add(new ArrayList<>(tmp));
        dfs(lists, tmp, nums, 0);
        return lists;
    }

    private void dfs(List<List<Integer>> lists, ArrayList<Integer> tmp, int[] nums, int index) {
        if (index == lists.size()){
            return;
        }
        for (int i = index; i < nums.length; i++) {//横向遍历
            tmp.add(nums[i]);
            lists.add(new ArrayList<>(tmp));
            dfs(lists, tmp, nums, i+1);//纵向递归
            tmp.remove(tmp.size()-1);
        }
    }
```
## 90、子集 II
带重复数据的子集，回溯，在78题的基础上进行剪枝，如果横向遍历的数据与上一个数据相等，就剪掉
```java
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        List<List<Integer>> lists = new ArrayList<>();
        if (nums == null || nums.length == 0){
            return lists;
        }
        Arrays.sort(nums);
        ArrayList<Integer> tmp = new ArrayList<>();
        lists.add(new ArrayList<>(tmp));
        dfs(lists, tmp, nums, 0);
        return lists;
    }

    private void dfs(List<List<Integer>> lists, ArrayList<Integer> tmp, int[] nums, int index) {
        if (index == lists.size()){
            return;
        }
        for (int i = index; i < nums.length; i++) {
            if (i > index && nums[i] == nums[i-1]){
                continue;
            }
            tmp.add(nums[i]);
            lists.add(new ArrayList<>(tmp));
            dfs(lists, tmp, nums, i+1);
            tmp.remove(tmp.size()-1);
        }
    }
```



## 17、电话号码的字母组合
hashmap保存数字对应的九键键盘上的字母组合，进行回溯
```java
    public List<String> letterCombinations(String digits) {
        List<String> res = new ArrayList<>();
        if (digits == null || digits.length() == 0){
            return res;
        }
        HashMap<Character, String> map = new HashMap<>();
        map.put('2',"abc");
        map.put('3',"def");
        map.put('4',"ghi");
        map.put('5',"jkl");
        map.put('6',"mno");
        map.put('7',"pqrs");
        map.put('8',"tuv");
        map.put('9',"wxyz");
        StringBuilder builder = new StringBuilder();
        dfs(res, builder, digits, map, 0);
        return res;
    }

    private void dfs(List<String> res, StringBuilder builder, String digits, HashMap<Character, String> map, int index) {
        if (index == digits.length()){
            res.add(builder.toString());
            return;
        }
        String nums = map.get(digits.charAt(index));
        for (int j = 0; j < nums.length(); j++) {
            builder.append(nums.charAt(j));
            dfs(res, builder, digits, map, index+1);
            builder.deleteCharAt(builder.length()-1);
        }
    }
```
## 131、分割回文串
回溯，判断回文进行剪枝，for循环横向找切割点，dfs纵向找切割点，所以dfs的下一个位置是i+1，是纵向的点，不是index+1
```java
    public List<List<String>> partition(String s) {
        List<List<String>> res = new ArrayList<>();
        if (s == null || s.length() == 0){
            return res;
        }
        ArrayList<String> tmp = new ArrayList<>();
        dfs(res, tmp, s, 0);
        return res;
    }

    private void dfs(List<List<String>> res, ArrayList<String> tmp, String s, int index) {
        if (index >= s.length()){
            res.add(new ArrayList<>(tmp));
            return;
        }
        for (int i = index; i < s.length(); i++) {
            if (!checkPalin(s, index, i)){
                continue;
            }
            tmp.add(s.substring(index, i+1));
            dfs(res, tmp, s, i+1);
            tmp.remove(tmp.size()-1);
        }
    }

    private boolean checkPalin(String s, int left, int right) {
        while (left <= right){
            if (s.charAt(left) != s.charAt(right)){
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
```

