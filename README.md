# leetcode
- 1、两数之和：map做辅助，实现O(N)
- 2、两数相加：注意最后一个进位
- 3、无重复字符的最长子串：滑动窗口，可以使用map记录char的位置，left可以一步直接挪到其之后
- 4、寻找两个正序数组的中位数：二分思想，要考虑奇数和偶数情况，每次在两个数组中取第k/2个数，比较大小，较小的那个可以舍弃前面k/2的数据【因为中位数一定会比这个值大】
- 5、最长回文子串：动态规划 dp[i][j] = dp[i+1][j-1] && s[i]==s[j]；解法二，中心扩展法 分别以s[i]和s[i]s[j]为中心扩散找回文子串

- 9、回文数：统计出位数，然后双指针取左右边界的数判断是否回文



- 76、最小覆盖子串：滑动窗口，map记录需要的字符个数，misscount记录还差几个字符，进行窗口边界调整


- 131、分割回文串：回溯，判断回文进行剪枝，for循环横向找切割点，dfs纵向找切割点，所以dfs的下一个位置是i+1


- 234、回文链表：快慢指针找中点，反转后半段，对比


- 647、回文子串：和第5题一样，使用动态规划或者中心扩展法
